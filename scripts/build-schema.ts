/**
 * build-schema.ts
 *
 * Prisma Multi-Schema Build Script for FANTACONTRATTI
 *
 * This script combines multiple .prisma files from prisma/schemas/ into a single
 * generated schema file. This allows for better organization of large schemas.
 *
 * Usage: tsx scripts/build-schema.ts
 *
 * The script:
 * 1. Reads the header (generator + datasource) from prisma/schema.prisma
 * 2. Reads all .prisma files from prisma/schemas/ directory
 * 3. Combines them in alphabetical order (files starting with _ come first)
 * 4. Writes the combined schema to prisma/schema.generated.prisma
 */

import * as fs from 'fs';
import * as path from 'path';

// Paths
const ROOT_DIR = path.resolve(import.meta.dirname, '..');
const PRISMA_DIR = path.join(ROOT_DIR, 'prisma');
const SCHEMAS_DIR = path.join(PRISMA_DIR, 'schemas');
const MAIN_SCHEMA = path.join(PRISMA_DIR, 'schema.prisma');
const OUTPUT_SCHEMA = path.join(PRISMA_DIR, 'schema.generated.prisma');

/**
 * Extract the header (generator + datasource blocks) from the main schema
 */
function extractHeader(schemaContent: string): string {
  const lines = schemaContent.split('\n');
  const headerLines: string[] = [];
  let inBlock = false;
  let blockCount = 0;

  for (const line of lines) {
    // Detect start of generator or datasource block
    if (line.match(/^(generator|datasource)\s+\w+\s*\{/)) {
      inBlock = true;
      blockCount++;
    }

    if (inBlock || line.trim().startsWith('//') && blockCount === 0) {
      headerLines.push(line);
    }

    // Detect end of block
    if (inBlock && line.trim() === '}') {
      inBlock = false;
      headerLines.push(''); // Add empty line after block

      // Stop after datasource block (we only want generator + datasource)
      if (blockCount >= 2) {
        break;
      }
    }
  }

  return headerLines.join('\n');
}

/**
 * Read all .prisma files from the schemas directory
 */
function readSchemaFiles(): { filename: string; content: string }[] {
  if (!fs.existsSync(SCHEMAS_DIR)) {
    console.error(`Error: Schemas directory not found: ${SCHEMAS_DIR}`);
    console.log('Creating schemas directory...');
    fs.mkdirSync(SCHEMAS_DIR, { recursive: true });
    return [];
  }

  const files = fs.readdirSync(SCHEMAS_DIR)
    .filter(f => f.endsWith('.prisma'))
    .sort((a, b) => {
      // Files starting with _ come first
      const aHasPrefix = a.startsWith('_');
      const bHasPrefix = b.startsWith('_');

      if (aHasPrefix && !bHasPrefix) return -1;
      if (!aHasPrefix && bHasPrefix) return 1;

      return a.localeCompare(b);
    });

  return files.map(filename => ({
    filename,
    content: fs.readFileSync(path.join(SCHEMAS_DIR, filename), 'utf-8')
  }));
}

/**
 * Strip comments that are just placeholders (empty schema files)
 */
function stripPlaceholderComments(content: string): string {
  // Remove lines that are only comments or whitespace at the start/end
  const lines = content.split('\n');
  let hasActualContent = false;

  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith('//')) {
      hasActualContent = true;
      break;
    }
  }

  // If file only has comments, return empty string
  if (!hasActualContent) {
    return '';
  }

  return content;
}

/**
 * Build the combined schema
 */
function buildSchema(): void {
  console.log('üîß Building Prisma schema...\n');

  // Check if main schema exists
  if (!fs.existsSync(MAIN_SCHEMA)) {
    console.error(`Error: Main schema not found: ${MAIN_SCHEMA}`);
    process.exit(1);
  }

  // Read main schema
  const mainSchemaContent = fs.readFileSync(MAIN_SCHEMA, 'utf-8');
  const header = extractHeader(mainSchemaContent);

  console.log('üìÑ Header extracted from schema.prisma');

  // Read schema files
  const schemaFiles = readSchemaFiles();

  if (schemaFiles.length === 0) {
    console.log('\n‚ö†Ô∏è  No schema files found in prisma/schemas/');
    console.log('   Create .prisma files in that directory to use multi-schema.');
    console.log('   For now, copying main schema as-is.\n');

    // Just copy the main schema
    fs.writeFileSync(OUTPUT_SCHEMA, mainSchemaContent);
    console.log(`‚úÖ Schema copied to: ${OUTPUT_SCHEMA}`);
    return;
  }

  console.log(`\nüìÅ Found ${schemaFiles.length} schema file(s):`);
  schemaFiles.forEach(f => console.log(`   - ${f.filename}`));

  // Build combined schema
  const parts: string[] = [
    '// =============================================================================',
    '// GENERATED FILE - DO NOT EDIT DIRECTLY',
    '// =============================================================================',
    '// This file is auto-generated by scripts/build-schema.ts',
    '// To make changes, edit the source files in prisma/schemas/',
    '// Then run: npm run db:build-schema',
    '// =============================================================================',
    '',
    header
  ];

  // Add each schema file
  for (const { filename, content } of schemaFiles) {
    const strippedContent = stripPlaceholderComments(content);

    if (strippedContent.trim()) {
      parts.push('');
      parts.push(`// =============================================================================`);
      parts.push(`// Source: prisma/schemas/${filename}`);
      parts.push(`// =============================================================================`);
      parts.push(strippedContent);
    }
  }

  // Write output
  const outputContent = parts.join('\n');
  fs.writeFileSync(OUTPUT_SCHEMA, outputContent);

  console.log(`\n‚úÖ Schema built successfully!`);
  console.log(`   Output: ${OUTPUT_SCHEMA}`);
  console.log(`\nüìù Next steps:`);
  console.log(`   1. Review the generated schema`);
  console.log(`   2. Run: npx prisma generate --schema=prisma/schema.generated.prisma`);
  console.log(`   3. Or update your prisma commands to use the generated schema`);
}

// Run
buildSchema();
