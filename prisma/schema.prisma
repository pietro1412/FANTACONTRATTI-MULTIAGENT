// schema.prisma - Schema completo Fantacontratti MVP

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_URL_UNPOOLED")
}

// ==================== UTENTI ====================
model User {
  id            String   @id @default(cuid())
  email         String   @unique
  username      String   @unique
  passwordHash  String
  emailVerified Boolean  @default(false)
  isSuperAdmin  Boolean  @default(false)  // Superadmin piattaforma (gestisce quotazioni)
  profilePhoto  String?  // URL della foto profilo (base64 o path)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relazioni
  leagueMemberships LeagueMember[]
  sentOffers        TradeOffer[]     @relation("OfferSender")
  receivedOffers    TradeOffer[]     @relation("OfferReceiver")
  auctionBids       AuctionBid[]
  auditLogs         AuditLog[]
  sentInvites       LeagueInvite[]
  quotazioniUploads QuotazioniUpload[]
}

// ==================== UPLOAD QUOTAZIONI ====================
model QuotazioniUpload {
  id            String   @id @default(cuid())

  uploadedById  String
  uploadedBy    User     @relation(fields: [uploadedById], references: [id])

  fileName      String
  sheetName     String

  // Risultati import
  playersCreated   Int
  playersUpdated   Int
  playersNotInList Int
  totalProcessed   Int
  errors           Json?    // Array of error strings

  createdAt     DateTime @default(now())
}

// ==================== LEGHE ====================
model League {
  id               String   @id @default(cuid())
  name             String
  description      String?

  // Vincoli partecipanti
  minParticipants  Int      @default(6)
  maxParticipants  Int      @default(20)
  requireEvenNumber Boolean @default(true)

  initialBudget    Int      @default(500)

  // Slot rosa
  goalkeeperSlots  Int      @default(3)
  defenderSlots    Int      @default(8)
  midfielderSlots  Int      @default(8)
  forwardSlots     Int      @default(6)

  // Stato
  status           LeagueStatus @default(DRAFT)
  currentSeason    Int          @default(1)

  // Codice invito
  inviteCode       String   @unique @default(cuid())

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relazioni
  members          LeagueMember[]
  marketSessions   MarketSession[]
  auctions         Auction[]
  auditLogs        AuditLog[]
  invites          LeagueInvite[]
  playerMovements  PlayerMovement[]
  prophecies       Prophecy[]
  prizes           Prize[]
}

enum LeagueStatus {
  DRAFT
  ACTIVE
  ARCHIVED
}

// ==================== MEMBRI LEGA ====================
model LeagueMember {
  id          String   @id @default(cuid())

  userId      String
  user        User     @relation(fields: [userId], references: [id])

  leagueId    String
  league      League   @relation(fields: [leagueId], references: [id])

  role        MemberRole @default(MANAGER)
  teamName    String?
  status      MemberStatus @default(PENDING)

  // Come è entrato nella lega
  joinType    JoinType @default(REQUEST)

  // Budget
  currentBudget Int    @default(0)

  // Ordine Rubata (impostato da admin)
  rubataOrder   Int?

  // Ordine turno primo mercato (impostato da admin)
  firstMarketOrder Int?

  joinedAt    DateTime @default(now())

  // Relazioni
  roster      PlayerRoster[]
  contracts   PlayerContract[]
  draftContracts DraftContract[]
  wonAuctions Auction[]        @relation("AuctionWinner")
  bids        AuctionBid[]
  movementsFrom PlayerMovement[] @relation("MovementFrom")
  movementsTo   PlayerMovement[] @relation("MovementTo")
  prophecies    Prophecy[]
  auctionAcknowledgments AuctionAcknowledgment[]
  contractConsolidations ContractConsolidation[]
  prizesReceived Prize[]
  prizesGiven    Prize[] @relation("PrizeAdmin")
  appeals        AuctionAppeal[]
  appealsResolved AuctionAppeal[] @relation("AppealResolver")
  chatMessages   ChatMessage[]
  sessionPrizes  SessionPrize[]

  @@unique([userId, leagueId])
}

enum JoinType {
  CREATOR   // Creatore della lega (auto-admin)
  INVITE    // Invitato via email (auto-entra)
  REQUEST   // Richiesta spontanea (admin approva)
}

enum MemberRole {
  ADMIN
  MANAGER
}

enum MemberStatus {
  PENDING
  ACTIVE
  SUSPENDED
  LEFT
}

// ==================== GIOCATORI SERIE A ====================
model SerieAPlayer {
  id           String   @id @default(cuid())
  externalId   String?  @unique     // ID dal file quotazioni (es. "123")
  name         String
  team         String
  position     Position
  quotation    Int      @default(1)
  age          Int?
  isActive     Boolean  @default(true)

  // Status nella lista quotazioni
  listStatus   PlayerListStatus @default(IN_LIST)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relazioni
  rosters      PlayerRoster[]
  auctions     Auction[]
  movements    PlayerMovement[]
  prophecies   Prophecy[]
  pendingNominations MarketSession[] @relation("PendingNomination")
}

enum PlayerListStatus {
  IN_LIST       // Presente nella lista quotazioni corrente
  NOT_IN_LIST   // Non più in lista (serie B, estero, etc.)
}

enum Position {
  P  // Portiere
  D  // Difensore
  C  // Centrocampista
  A  // Attaccante
}

// ==================== ROSA MANAGER ====================
model PlayerRoster {
  id              String   @id @default(cuid())

  leagueMemberId  String
  leagueMember    LeagueMember @relation(fields: [leagueMemberId], references: [id])

  playerId        String
  player          SerieAPlayer @relation(fields: [playerId], references: [id])

  acquisitionPrice Int
  acquisitionType  AcquisitionType

  status          RosterStatus @default(ACTIVE)
  acquiredAt      DateTime     @default(now())
  releasedAt      DateTime?

  // Relazioni
  contract        PlayerContract?
  draftContract   DraftContract?

  @@unique([leagueMemberId, playerId, status])
}

enum AcquisitionType {
  FIRST_MARKET
  RUBATA
  SVINCOLATI
  TRADE
}

enum RosterStatus {
  ACTIVE
  RELEASED
  TRADED
}

// ==================== CONTRATTI ====================
model PlayerContract {
  id              String   @id @default(cuid())

  rosterId        String   @unique
  roster          PlayerRoster @relation(fields: [rosterId], references: [id])

  leagueMemberId  String
  leagueMember    LeagueMember @relation(fields: [leagueMemberId], references: [id])

  // Parametri contratto
  salary          Int      // Ingaggio
  duration        Int      // Durata (1-4 semestri)
  initialSalary   Int      // Per validazione rinnovi
  initialDuration Int      // Per validazione rinnovi

  // Calcolato
  rescissionClause Int     // salary * multiplier

  // Bozza rinnovo (staging area)
  draftSalary     Int?     // Nuovo ingaggio proposto
  draftDuration   Int?     // Nuova durata proposta
  draftReleased   Boolean  @default(false)  // Marcato per taglio (pending)

  signedAt        DateTime @default(now())
  expiresAt       DateTime?

  // Storico rinnovi
  renewalHistory  Json?    // [{salary, duration, renewedAt}]
}

// Bozza per nuovi contratti (giocatori senza contratto)
model DraftContract {
  id              String   @id @default(cuid())

  rosterId        String   @unique
  roster          PlayerRoster @relation(fields: [rosterId], references: [id])

  memberId        String
  member          LeagueMember @relation(fields: [memberId], references: [id])

  sessionId       String
  session         MarketSession @relation(fields: [sessionId], references: [id])

  salary          Int
  duration        Int

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

// ==================== SESSIONI MERCATO ====================
model MarketSession {
  id          String   @id @default(cuid())

  leagueId    String
  league      League   @relation(fields: [leagueId], references: [id])

  type        MarketType
  season      Int
  semester    Int      // 1 = estivo, 2 = invernale

  status      SessionStatus @default(SCHEDULED)
  currentPhase MarketPhase?

  // ===== PRIMO MERCATO ASSOLUTO =====
  // Ruolo attualmente in asta (P, D, C, A)
  currentRole       Position?
  // Ordine turni per primo mercato (JSON array di leagueMemberId)
  turnOrder         Json?
  // Indice del turno corrente
  currentTurnIndex  Int?
  // Timer asta in secondi (configurabile da admin)
  auctionTimerSeconds Int @default(30)

  // ===== RUBATA =====
  // Ordine rubata per questa sessione (JSON array di leagueMemberId)
  rubataOrder  Json?
  // Tabellone rubata ordinato (JSON array di {rosterId, memberId, playerId})
  rubataBoard  Json?
  // Indice corrente nel tabellone (quale giocatore è in esame)
  rubataBoardIndex Int?
  // Timer per offerta iniziale in secondi
  rubataOfferTimerSeconds Int @default(30)
  // Timer per asta rubata in secondi
  rubataAuctionTimerSeconds Int @default(15)
  // Timestamp quando il timer corrente è iniziato
  rubataTimerStartedAt DateTime?
  // Stato rubata: WAITING (aspetta admin), READY_CHECK, OFFERING (timer offerta), AUCTION_READY_CHECK (attesa pronti pre-asta), AUCTION (asta attiva), PENDING_ACK, PAUSED, COMPLETED
  rubataState String?
  // Manager pronti per iniziare/riprendere rubata (JSON array di leagueMemberId)
  rubataReadyMembers Json?
  // Info per annuncio rubata durante AUCTION_READY_CHECK (JSON: {bidderUsername, playerName, playerTeam, playerPosition, ownerUsername, basePrice})
  rubataAuctionReadyInfo Json?
  // Pending acknowledgment dopo chiusura asta rubata (JSON: {auctionId, playerId, winnerId, price, acknowledgedMembers[], pendingMembers[]})
  rubataPendingAck Json?

  // ===== ASTA SVINCOLATI =====
  // Ordine turni svincolati (JSON array di leagueMemberId)
  svincolatiTurnOrder     Json?
  // Indice del turno corrente
  svincolatiCurrentTurnIndex Int?
  // Timer asta svincolati in secondi
  svincolatiTimerSeconds  Int @default(30)
  // Timestamp quando il timer corrente è iniziato
  svincolatiTimerStartedAt DateTime?
  // Stato svincolati: SETUP, READY_CHECK, NOMINATION, AUCTION, PENDING_ACK, COMPLETED
  svincolatiState         String?
  // Manager pronti per la prossima asta (JSON array di leagueMemberId)
  svincolatiReadyMembers  Json?
  // Manager che hanno passato (non vogliono più chiamare) (JSON array di leagueMemberId)
  svincolatiPassedMembers Json?
  // Manager che hanno dichiarato di aver finito la fase (non possono più fare offerte) (JSON array di leagueMemberId)
  svincolatiFinishedMembers Json?
  // Giocatore svincolato nominato in attesa (playerId)
  svincolatiPendingPlayerId String?
  // Chi ha nominato il giocatore pending
  svincolatiPendingNominatorId String?
  // Se il nominatore ha confermato
  svincolatiNominatorConfirmed Boolean @default(false)
  // Pending acknowledgment dopo chiusura asta (JSON: {auctionId, playerId, winnerId, price, acknowledgedMembers[], pendingMembers[]})
  svincolatiPendingAck    Json?

  // ===== READY CHECK =====
  // Manager pronti per la prossima asta (JSON array di leagueMemberId)
  // Resettato quando un'asta viene nominata
  readyMembers Json?
  // Giocatore nominato in attesa di ready check (null se nessuna nomination pending)
  pendingNominationPlayerId String?
  pendingNominationPlayer   SerieAPlayer? @relation("PendingNomination", fields: [pendingNominationPlayerId], references: [id])
  // Chi ha nominato il giocatore pending
  pendingNominatorId        String?
  // Se il nominatore ha confermato la sua scelta (gli altri vedono "SONO PRONTO" solo dopo)
  nominatorConfirmed        Boolean @default(false)

  startsAt    DateTime?
  endsAt      DateTime?

  // Timestamp inizio fase corrente (aggiornato ad ogni cambio fase)
  phaseStartedAt DateTime?

  createdAt   DateTime @default(now())

  // Relazioni
  auctions    Auction[]
  trades      TradeOffer[]
  movements   PlayerMovement[]
  consolidations ContractConsolidation[]
  draftContracts DraftContract[]
  chatMessages ChatMessage[]
  prizePhaseConfig PrizePhaseConfig?
  prizeCategories  PrizeCategory[]

  // Indice per velocizzare ricerca sessioni attive per lega
  @@index([leagueId, status])
  // Indice per verificare esistenza PRIMO_MERCATO
  @@index([leagueId, type])
}

// ==================== CONSOLIDAMENTO CONTRATTI ====================
// Traccia quali manager hanno consolidato i propri contratti durante la fase CONTRATTI
model ContractConsolidation {
  id          String   @id @default(cuid())

  sessionId   String
  session     MarketSession @relation(fields: [sessionId], references: [id])

  memberId    String
  member      LeagueMember @relation(fields: [memberId], references: [id])

  consolidatedAt DateTime @default(now())

  @@unique([sessionId, memberId])
}

// ==================== PREMI ====================
// Traccia i premi assegnati dall'admin ai manager
model Prize {
  id          String   @id @default(cuid())

  leagueId    String
  league      League   @relation(fields: [leagueId], references: [id])

  memberId    String
  member      LeagueMember @relation(fields: [memberId], references: [id])

  adminId     String
  admin       LeagueMember @relation("PrizeAdmin", fields: [adminId], references: [id])

  amount      Int
  reason      String?

  createdAt   DateTime @default(now())
}

// ==================== FASE PREMI (MERCATO RICORRENTE) ====================
// Configurazione fase PREMI per sessione di mercato
model PrizePhaseConfig {
  id                String        @id @default(cuid())
  marketSessionId   String        @unique
  marketSession     MarketSession @relation(fields: [marketSessionId], references: [id], onDelete: Cascade)
  baseReincrement   Int           @default(100)  // Re-incremento base uguale per tutti
  isFinalized       Boolean       @default(false)
  finalizedAt       DateTime?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
}

// Categoria premio (es. "Classifica Portieri", "Indennizzo Partenza Estero")
model PrizeCategory {
  id                String         @id @default(cuid())
  marketSessionId   String
  marketSession     MarketSession  @relation(fields: [marketSessionId], references: [id], onDelete: Cascade)
  name              String
  isSystemPrize     Boolean        @default(false)  // true per "Indennizzo Partenza Estero"
  managerPrizes     SessionPrize[]
  createdAt         DateTime       @default(now())

  @@unique([marketSessionId, name])
}

// Premio assegnato a un manager per questa sessione
model SessionPrize {
  id              String        @id @default(cuid())
  prizeCategoryId String
  prizeCategory   PrizeCategory @relation(fields: [prizeCategoryId], references: [id], onDelete: Cascade)
  leagueMemberId  String
  leagueMember    LeagueMember  @relation(fields: [leagueMemberId], references: [id], onDelete: Cascade)
  amount          Int           // Importo assegnato
  createdAt       DateTime      @default(now())

  @@unique([prizeCategoryId, leagueMemberId])
}

enum MarketType {
  PRIMO_MERCATO
  MERCATO_RICORRENTE
}

enum SessionStatus {
  SCHEDULED
  ACTIVE
  COMPLETED
  CANCELLED
}

enum MarketPhase {
  ASTA_LIBERA                    // Solo per PRIMO_MERCATO
  OFFERTE_PRE_RINNOVO            // Prima fase MERCATO_RICORRENTE - scambi/offerte pre rinnovo
  PREMI                          // Assegnazione premi budget ai manager
  CONTRATTI                      // Rinnovo contratti
  RUBATA                         // Asta forzata
  ASTA_SVINCOLATI                // Asta svincolati (solo MERCATO_RICORRENTE)
  OFFERTE_POST_ASTA_SVINCOLATI   // Fase finale - scambi/offerte post svincolati
}

// ==================== ASTE ====================
model Auction {
  id              String   @id @default(cuid())

  leagueId        String
  league          League   @relation(fields: [leagueId], references: [id])

  marketSessionId String?
  marketSession   MarketSession? @relation(fields: [marketSessionId], references: [id])

  playerId        String
  player          SerieAPlayer @relation(fields: [playerId], references: [id])

  type            AuctionType
  basePrice       Int         @default(1)  // Sempre 1 per default
  currentPrice    Int

  winnerId        String?
  winner          LeagueMember? @relation("AuctionWinner", fields: [winnerId], references: [id])

  // Per rubata: chi sta cedendo
  sellerId        String?

  // Chi ha nominato il giocatore (per primo mercato)
  nominatorId     String?

  status          AuctionStatus @default(PENDING)

  // Timer con reset
  timerExpiresAt  DateTime?     // Quando scade il timer attuale
  timerSeconds    Int?          // Durata timer in secondi

  startsAt        DateTime?
  endsAt          DateTime?

  createdAt       DateTime @default(now())

  // Per gestione ricorsi - chi ha preso visione della decisione
  appealDecisionAcks  Json?     // Array di memberId che hanno confermato la decisione
  // Per ripresa asta dopo ricorso ACCEPTED - chi è pronto
  resumeReadyMembers  Json?     // Array di memberId pronti a riprendere

  // Relazioni
  bids            AuctionBid[]
  acknowledgments AuctionAcknowledgment[]
  appeals         AuctionAppeal[]
}

enum AuctionType {
  FREE_BID        // Asta libera (PRIMO MERCATO e SVINCOLATI)
  RUBATA          // Asta rubata (forzata)
}

enum AuctionStatus {
  PENDING
  ACTIVE
  COMPLETED
  CANCELLED
  NO_BIDS
  APPEAL_REVIEW           // Asta conclusa ma con ricorso PENDING da gestire
  AWAITING_APPEAL_ACK     // Ricorso risolto, in attesa che tutti prendano visione
  AWAITING_RESUME         // Ricorso ACCEPTED, in attesa ready check per riprendere
}

model AuctionBid {
  id          String   @id @default(cuid())

  auctionId   String
  auction     Auction  @relation(fields: [auctionId], references: [id])

  bidderId    String
  bidder      LeagueMember @relation(fields: [bidderId], references: [id])

  userId      String
  user        User     @relation(fields: [userId], references: [id])

  amount      Int
  isWinning   Boolean  @default(false)

  // Admin può annullare un'offerta
  isCancelled Boolean  @default(false)
  cancelledAt DateTime?
  cancelledBy String?   // userId dell'admin che ha annullato

  placedAt    DateTime @default(now())
}

// Conferma visualizzazione risultato asta
model AuctionAcknowledgment {
  id          String   @id @default(cuid())

  auctionId   String
  auction     Auction  @relation(fields: [auctionId], references: [id])

  memberId    String
  member      LeagueMember @relation(fields: [memberId], references: [id])

  // Profezia opzionale inserita dal manager
  prophecy    String?

  acknowledgedAt DateTime @default(now())

  @@unique([auctionId, memberId])
}

// Ricorsi su aste concluse
model AuctionAppeal {
  id          String   @id @default(cuid())

  auctionId   String
  auction     Auction  @relation(fields: [auctionId], references: [id])

  // Chi ha fatto il ricorso
  memberId    String
  member      LeagueMember @relation(fields: [memberId], references: [id])

  // Motivazione del ricorso
  content     String

  // Stato del ricorso
  status      AppealStatus @default(PENDING)

  // Admin che ha risolto il ricorso
  resolvedById String?
  resolvedBy   LeagueMember? @relation("AppealResolver", fields: [resolvedById], references: [id])

  // Note admin sulla risoluzione
  resolutionNote String?

  resolvedAt  DateTime?
  createdAt   DateTime @default(now())
}

enum AppealStatus {
  PENDING    // In attesa di revisione
  ACCEPTED   // Accettato - asta riaperta
  REJECTED   // Respinto - esito confermato
}

// ==================== SCAMBI ====================
model TradeOffer {
  id              String   @id @default(cuid())

  marketSessionId String
  marketSession   MarketSession @relation(fields: [marketSessionId], references: [id])

  senderId        String
  sender          User     @relation("OfferSender", fields: [senderId], references: [id])

  receiverId      String
  receiver        User     @relation("OfferReceiver", fields: [receiverId], references: [id])

  // Offerta
  offeredPlayers  Json     // [playerId, ...]
  offeredBudget   Int      @default(0)

  // Richiesta
  requestedPlayers Json    // [playerId, ...]
  requestedBudget  Int     @default(0)

  status          TradeStatus @default(PENDING)

  // Per vincolo anti-ritroso
  involvedPlayers Json     // tutti i playerId coinvolti

  message         String?

  createdAt       DateTime @default(now())
  expiresAt       DateTime?  // Scadenza dell'offerta
  respondedAt     DateTime?

  // Controproposta
  parentOfferId   String?
  parentOffer     TradeOffer?  @relation("CounterOffers", fields: [parentOfferId], references: [id])
  counterOffers   TradeOffer[] @relation("CounterOffers")
}

enum TradeStatus {
  PENDING
  ACCEPTED
  REJECTED
  COUNTERED
  CANCELLED
  EXPIRED
}

// ==================== AUDIT LOG ====================
model AuditLog {
  id          String   @id @default(cuid())

  userId      String?
  user        User?    @relation(fields: [userId], references: [id])

  leagueId    String?
  league      League?  @relation(fields: [leagueId], references: [id])

  action      String
  entityType  String?
  entityId    String?
  oldValues   Json?
  newValues   Json?

  ipAddress   String?
  userAgent   String?

  createdAt   DateTime @default(now())
}

// ==================== INVITI LEGA ====================
model LeagueInvite {
  id          String   @id @default(cuid())

  leagueId    String
  league      League   @relation(fields: [leagueId], references: [id])

  email       String
  token       String   @unique

  invitedBy   String
  inviter     User     @relation(fields: [invitedBy], references: [id])

  status      InviteStatus @default(PENDING)

  expiresAt   DateTime
  acceptedAt  DateTime?

  createdAt   DateTime @default(now())

  @@unique([leagueId, email])
}

enum InviteStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

// ==================== STORICO MOVIMENTI ====================
model PlayerMovement {
  id              String   @id @default(cuid())

  leagueId        String
  league          League   @relation(fields: [leagueId], references: [id])

  playerId        String
  player          SerieAPlayer @relation(fields: [playerId], references: [id])

  // Tipo movimento
  movementType    MovementType

  // Da chi / A chi
  fromMemberId    String?
  fromMember      LeagueMember? @relation("MovementFrom", fields: [fromMemberId], references: [id])

  toMemberId      String?
  toMember        LeagueMember? @relation("MovementTo", fields: [toMemberId], references: [id])

  // Dettagli movimento
  price           Int?

  // Contratto precedente (snapshot)
  oldSalary       Int?
  oldDuration     Int?
  oldClause       Int?

  // Nuovo contratto (snapshot)
  newSalary       Int?
  newDuration     Int?
  newClause       Int?

  // Riferimento all'asta/scambio se applicabile
  auctionId       String?
  tradeId         String?

  // Sessione mercato
  marketSessionId String?
  marketSession   MarketSession? @relation(fields: [marketSessionId], references: [id])

  createdAt       DateTime @default(now())

  // Relazioni
  prophecies      Prophecy[]
}

enum MovementType {
  FIRST_MARKET    // Primo mercato assoluto
  TRADE           // Scambio
  RUBATA          // Rubata
  SVINCOLATI      // Acquisto svincolato
  RELEASE         // Svincolo (contratto scaduto o volontario)
  CONTRACT_RENEW  // Rinnovo contratto
}

// ==================== PROFEZIE ====================
model Prophecy {
  id              String   @id @default(cuid())

  leagueId        String
  league          League   @relation(fields: [leagueId], references: [id])

  playerId        String
  player          SerieAPlayer @relation(fields: [playerId], references: [id])

  // Chi ha fatto la profezia
  authorId        String
  author          LeagueMember @relation(fields: [authorId], references: [id])

  // Movimento associato
  movementId      String
  movement        PlayerMovement @relation(fields: [movementId], references: [id])

  // Tipo: acquirente o cedente
  authorRole      ProphecyRole

  // Contenuto profezia
  content         String

  createdAt       DateTime @default(now())

  @@unique([movementId, authorId])
}

enum ProphecyRole {
  BUYER   // Chi acquista
  SELLER  // Chi cede
}

// ==================== CHAT ASTA ====================
model ChatMessage {
  id              String   @id @default(cuid())

  marketSessionId String
  marketSession   MarketSession @relation(fields: [marketSessionId], references: [id])

  memberId        String
  member          LeagueMember @relation(fields: [memberId], references: [id])

  content         String

  // Per messaggi di sistema (es. "Asta iniziata", "Giocatore nominato")
  isSystem        Boolean  @default(false)

  createdAt       DateTime @default(now())
}
